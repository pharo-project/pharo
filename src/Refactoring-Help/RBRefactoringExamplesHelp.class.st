"
This chapter of the refactoring help book is about how to manually use the refactoring operations.
"
Class {
	#name : #RBRefactoringExamplesHelp,
	#superclass : #RefactoringHelp,
	#category : #'Refactoring-Help'
}

{ #category : #accessing }
RBRefactoringExamplesHelp class >> bookName [
	^ 'Refactoring Examples'
]

{ #category : #pages }
RBRefactoringExamplesHelp class >> combineOperationsExample [
	^HelpTopic
		title: 'Combining operations - Add class with instance variables'
		contents: 
'
As we saw, the RBAddClassRefactoring does not allow us to define any instance variables. Instead we can add a new class and then apply another refactoring, RBAddInstanceVariableRefactoring.
We just need to call them in the appropriate order and make sure that both operations operate on the same model - otherwise the instance variable refactoring would not know about the class it
should operate on.

  | model addClassRB addInstVarsRB browser |
    model := RBNamespace new.
    addClassRB := RBAddClassRefactoring
        model: model
        addClass: #SomeClass
        superclass: #Object
        subclasses: {}
        category: #Category.
    addClassRB primitiveExecute.
    addInstVarsRB := RBAddInstanceVariableRefactoring
        model: model
        variable: ''x''
        class: #SomeClass.
    addInstVarsRB primitiveExecute.
    browser := ChangesBrowser new.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open

It is important to actually execute the first operation before creating the second one. The instantiation of the RBAddInstanceVariableRefactoring will query the environment the class #SomeClass and
init the reference to nil if it doesn''t yet exists.

The changes browser now includes two refactorings, you can select only the second one but this won''t work.
If you applied both, and want to undo that changes, you''ll need to call two times:
RBRefactoryChangeManager instance undoOperation.
'
]

{ #category : #pages }
RBRefactoringExamplesHelp class >> firstExample [
	^HelpTopic
		title: 'A first example'
		contents: 
'
We want to add a new class with the RBAddClassRefactoring. (This is just a simple example, most of the time you won''t use a refactoring operation for adding new classes. But it is used by tools generating classes or by other refactoring operations (RBSplitClassRefactoring)).

First we need a namespace, a RBNamespace, it collects the changes generated by this operation and provides an environment for finding other classes / methods affected by the operation.
We create a ''default'' RBNamespace that represents an environment of all system classes. The RBAddClassRefactoring needs all the information needed for the class hierarchy (name/superclass/subclasses/category) and our namespace as the ''model''. The ChangesBrowser lists all the refactoring changes in a check box list. The reason for calling ''changes changes'' not the model is, because the first ''changes'' does not give a list of all changes but a RBCompositeRefactoryChange that actually holds the list of all changes.

  | model addClassRB browser |
    model := RBNamespace new.
    addClassRB := RBAddClassRefactoring
        model: model
        addClass: #SomeClass
        superclass: #Object
        subclasses: {}
        category: #Category.
    addClassRB primitiveExecute.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open

In the ChangesBrowser list of changes you can select which one to apply. Keep in mind that some compound refactorings may not show all intermediate changes.

The primitiveExecute method will check all preconditions for this Refactoring and either shows a warning or a refactoring error, if this operation can not be performed.
We can execute the above refactoring ''twice'' and will see the second time it shows an error about SomeClass already exists.

There is a global change manager - RBRefactoryChangeManager, we can use it to undo the last operation.

RBRefactoryChangeManager instance undoOperation.
and again redo
RBRefactoryChangeManager instance redoOperation.
and undo, and .... :)

'
]

{ #category : #pages }
RBRefactoringExamplesHelp class >> overview [
	^HelpTopic
		title: 'Overview'
		contents: 
'
This chapter describes the steps needed to set up an environment and fill in the data
to execute refactoring operations.

This enables you to execute refactorings that aren''t provided by the System Browser, or combining a set of operations for a more complex refactoring. It also gives a hint on how to add refactoring support for your own tools.


These are the steps used for all of the examples:
- create a RBNamespace
- instantiate the refactoring operation
- execute it (primitiveExecute)
- open a changes browser to view and apply the changes
  applying the changes will actually execute the code transformations ''for real''.
'
]

{ #category : #accessing }
RBRefactoringExamplesHelp class >> pages [
	^#( overview firstExample combineOperationsExample restrictedEnvironmentExample refactoringOptions)
]

{ #category : #pages }
RBRefactoringExamplesHelp class >> refactoringOptions [
	^HelpTopic
		title: 'Refactoring Options'
		contents: 
'
Some refactoring operations may require additional informations for performing the transformation. For example a ''move method '' refactoring, moving a method from one class to another may add an additional argument if the prior method had some ''self sends''. Some of the information are given by instantiating the refactoring and some information can be computed by the
operation itself. For other cases the refactoring may actually break code or create broken code. To make this operation still work the programmer or user of the refactoring engine
could provide the needed information. 

For this, the engine contains a set of ''options'' that can be set by the tool using the framework, to register callback functions used to aquire the information from the user.

The options that can be used are:

#implementorToInline - select one of a list of method names

#methodName - ask for a method name

#selfArgumentName - argument name to use for replacing self sends

#selectVariableToMoveTo - select one of a list of variable names

#variableTypes - select or provide a class

#extractAssignment - should the code extraction include the variable assignment

#inlineExpression - I don''t know

#alreadyDefined - Should it override  methods defined in the hierarchy.

#useExistingMethod - Should it use existing (equivalent) method

#openBrowser - call to open system browser

A tool now can register a callback like

refactoring setOption:#name_of_an_option toUse:[:a :b: ... a block with needed arguments]

for example, Calypso sets the option
#implementorToInline to a method showing a dialog with a list to choose one of the provided selector names.

In the following example we show how to set the needed options manually. The RBMoveMethodRefactoring will ask us three questions
- selfArgumentName
- variableTypes
- methodName

for all of this options we set a simple block that just returns the information needed for this example task. In a real world tool, we
would need some interactive tool to let the user make a choice.
This RBMoveMethodRefactoring will move the implementation from TestResult class>>#historyFor: to its argument of type TestCase

    | model rbMoveMethod browser |
    model := RBNamespace onEnvironment: RBBrowserEnvironment new.
    rbMoveMethod := RBMoveMethodRefactoring
        model: model
        selector: #historyFor:
        class: TestResult class
        variable: ''aTestCaseClass''.
    rbMoveMethod setOption: #selfArgumentName toUse: [ :ref | ''aResultClass'' ].
    rbMoveMethod
        setOption: #variableTypes
        toUse: [ :ref :types :selected | {(model classNamed: #TestCase)} ].
    rbMoveMethod
        setOption: #methodName
        toUse: [ :ref :name | RBMethodName selector: ''asHistoryFor:'' arguments: {''aTestResult''} ].
    rbMoveMethod primitiveExecute.
    browser := ChangesBrowser changes: model changes changes.
    browser open

The result of this operation is, the method #historyFor: is moved to the class TestCase and the former implementation is replaced by
  aTestCase asHistoryFor: self
as the former implementation had a call to self (self newTestDictionary) we need to add self as an argument for the new method.
The refactoring operation queries this argument name by calling the registered block for the option ''selfArgumentName'', as the refactoring can not guess the type
of the class we want to move the method, it will ask us by calling ''variableTypes'' and finally the new method name and arguments are provided by calling the block for option
''methodName''.
'
]

{ #category : #pages }
RBRefactoringExamplesHelp class >> restrictedEnvironmentExample [
	^HelpTopic
		title: 'Scoping Refactoring'
		contents: 
'
A refactoring operation often changes existing code by first, search for a pattern, and then transform the matching code into the new form. But in some situations you don''t want to apply the change to all found matches.
For example, you want to rename a method in all implementors and all callers of your package. If this method name is a common message in other (system) classes as well, you don''t want to rename all places and for sure you don''t want to go through the ChangesBrowser and unselect all those matches by hand.

We can restrict the search space by creating our namespace from a restricted browser environment.
(More about restricted environments in the chapter RBBrowserEnvironments)

In this example we will apply the RBPrettyPrintCodeRefactoring to all classes in the Package ''Tests'', by first creating a RBBrowserEnvironment for packages and then create the RBNamespace with this environment:

 | env model prettyPrintRB browser |
    env := RBBrowserEnvironment new forPackageNames:{''Tests''}.
    model := RBNamespace onEnvironment: env.
    prettyPrintRB := RBPrettyPrintCodeRefactoring new model: model; yourself.
    prettyPrintRB primitiveExecute.
    browser := ChangesBrowser new.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open

After applying this refactoring, all methods in all classes of the package ''Tests'' will be reformatted (pretty print).
'
]
