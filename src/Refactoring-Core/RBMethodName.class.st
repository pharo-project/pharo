"
I represent a method name (selector and arguments) in the refactoring framework.

I am used by refactoring operations - for example RBMoveMethodRefactoring.

I have a selector name and a list of arguments and I use RBScanner to validate the syntax of my selector name.

In the refactory framework I am used for representing a new method name, generated by the refactoring operation or requested by the caller.

You can create instances of me by 
RBMethodName selector: 'color:' arguments:{'aColor'}.
(RBMethodName selector:'color' arguments:{}) isValid.
"
Class {
	#name : 'RBMethodName',
	#superclass : 'Model',
	#instVars : [
		'selector',
		'arguments',
		'newArgs',
		'permutation',
		'renameMap'
	],
	#category : 'Refactoring-Core-Support',
	#package : 'Refactoring-Core',
	#tag : 'Support'
}

{ #category : 'instance creation' }
RBMethodName class >> selector: aSymbol arguments: stringCollection [
	^ self new
			selector: aSymbol;
			arguments: stringCollection;
			yourself
]

{ #category : 'accessing' }
RBMethodName >> arguments [
	^arguments
]

{ #category : 'accessing' }
RBMethodName >> arguments: nameCollection [
	arguments := nameCollection.
	self changed: #arguments
]

{ #category : 'testing' }
RBMethodName >> isValid [
	"Return whether the receiver looks like a method with a selector in sync with the arguments in a possible class"

	^ 	selector isString and: [ selector isValidSelector
			and: [ selector numArgs = arguments size ]]
]

{ #category : 'accessing' }
RBMethodName >> newArgs [

	^ newArgs ifNil: [ newArgs := { } ]
]

{ #category : 'accessing' }
RBMethodName >> newArgs: anObject [

	newArgs := anObject
]

{ #category : 'accessing' }
RBMethodName >> permutation [

	^ permutation ifNil: [ permutation := 1 to: arguments size ]
]

{ #category : 'accessing' }
RBMethodName >> permutation: anObject [

	permutation := anObject
]

{ #category : 'printing' }
RBMethodName >> printOn: aStream [
	| argumentStream |
	self isValid
		ifFalse: [ ^ aStream nextPutAll: '(invalid)' ].
	argumentStream := self arguments readStream.
	self selector keywords keysAndValuesDo: [ :key :part |
		key = 1 ifFalse: [ aStream space ].
		aStream nextPutAll: part.
		(self selector isUnary or: [ argumentStream atEnd ])
			ifTrue: [ ^ self ].
		aStream space; nextPutAll: argumentStream next ]
]

{ #category : 'accessing' }
RBMethodName >> renameMap [

	^ renameMap ifNil: [ renameMap := {  } ]
]

{ #category : 'accessing' }
RBMethodName >> renameMap: anObject [

	renameMap := anObject
]

{ #category : 'accessing' }
RBMethodName >> selector [
	^selector
]

{ #category : 'accessing' }
RBMethodName >> selector: aSymbol [
	selector := aSymbol asSymbol.
	self changed: #selector
]
