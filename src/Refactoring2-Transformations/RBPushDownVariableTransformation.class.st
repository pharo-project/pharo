"
Removes this variable from the given class, then adds this variable in all the subclasses of this class.

Usage:
transformation := (RBPushDownVariableTransformation 
		instanceVariable: 'foo1'
		class: #RBLintRuleTest)
		transform.
(ChangesBrowser changes: transformation model changes changes) open

Preconditions:
overriden from RBAddVariableTransformation and RBRemoveVariableAccessorTransformation
"
Class {
	#name : #RBPushDownVariableTransformation,
	#superclass : #RBCompositeVariableTransformation,
	#category : #'Refactoring2-Transformations-Model-Unused'
}

{ #category : #preconditions }
RBPushDownVariableTransformation >> applicabilityConditionsForClassVariable [
	"it does not perform when two subclasses (and/or their subclasses) accesses this variable"

	^ RBCondition
		  definesClassVariable: variableName
		  in: self definingClass
]

{ #category : #preconditions }
RBPushDownVariableTransformation >> applicabilityConditionsForInstanceVariable [

	^ RBCondition
		  definesInstanceVariable: variableName
		  in: self definingClass
]

{ #category : #preconditions }
RBPushDownVariableTransformation >> breakingChangeConditionsForClassVariable [

	^ RBCondition withBlock: [
		  | numSubclassesAccessing |
		  numSubclassesAccessing := self definingClass subclasses count: [
			                            :subclass |
			                            subclass withAllSubclasses anySatisfy: [
				                            :e |
				                            (e
					                             whichSelectorsReferToClassVariable:
					                             variableName) isNotEmpty or: [
					                            (e classSide
						                             whichSelectorsReferToClassVariable:
						                             variableName) isNotEmpty ] ] ].
		  numSubclassesAccessing < 2 ]
]

{ #category : #preconditions }
RBPushDownVariableTransformation >> breakingChangeConditionsForInstanceVariable [

	^ RBCondition
		  accessesInstanceVariable: variableName
		  in: self definingClass
		  showIn: self
]

{ #category : #executing }
RBPushDownVariableTransformation >> buildTransformations [

	^ OrderedCollection new
		add: (RBRemoveVariableTransformation
				model: self model
				variable: variableName
				class: className
				classVariable: isClassVariable);
		addAll: (self variableDefinitionsInHierarchy
			collect: [ :each |
				RBAddVariableTransformation
				model: self model
				variable: variableName
				class: each
				classVariable: isClassVariable ]);
		yourself
]

{ #category : #preconditions }
RBPushDownVariableTransformation >> preconditions [
	"it does not perform when two subclasses
	(and/or their subclasses) access this variable"

	^ isClassVariable
		ifTrue: [ self applicabilityConditionsForClassVariable ]
		ifFalse: [ self applicabilityConditionsForInstanceVariable ]
]

{ #category : #printing }
RBPushDownVariableTransformation >> storeOn: aStream [

	aStream nextPut: $(.
	self class storeOn: aStream.
	aStream nextPutAll: ' variable: '.
	variableName storeOn: aStream.
	aStream nextPutAll: ' class: '.
	className storeOn: aStream.
	aStream nextPutAll: ' classVariable: '.
	isClassVariable storeOn: aStream.
	aStream nextPut: $)
]

{ #category : #api }
RBPushDownVariableTransformation >> variable: aVariableName class: aClassName classVariable: aBoolean [

	variableName := aVariableName.
	isClassVariable := aBoolean.
	className := aClassName
]

{ #category : #private }
RBPushDownVariableTransformation >> variableDefinitionsInHierarchy [

	self flag: #pharoTodo. "why the behavior is different for class and instance variable?"
	^ isClassVariable
		ifTrue: [ self definingClass allSubclasses reject: [ :each |
			(each whichSelectorsReferToClassVariable: variableName) isEmpty
			and: [ (each classSide whichSelectorsReferToClassVariable: variableName) isEmpty ] ] ]
		ifFalse: [ self definingClass subclasses ]
]
