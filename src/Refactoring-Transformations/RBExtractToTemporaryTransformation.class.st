"
Add a new temporary variable for the value of the selected code. Every place in this method using the same piece of code is replaced by accessing this new temporary variable instead.
As the code is now only evaluated once for initializing the variable value, this refactoring may modify the behavior if the code statements didn't evaluate to the same value on every call.

My preconditions verify that the new temporary name is a valid name and isn't already used (neither a temporary, an instance variable or a class variable).
"
Class {
	#name : 'RBExtractToTemporaryTransformation',
	#superclass : 'RBCompositeMethodTransformation',
	#instVars : [
		'sourceInterval',
		'newVariableName',
		'parseTree'
	],
	#category : 'Refactoring-Transformations-Model-Migrated',
	#package : 'Refactoring-Transformations',
	#tag : 'Model-Migrated'
}

{ #category : 'api' }
RBExtractToTemporaryTransformation class >> extract: anInterval to: aString from: aSelector in: aClass [
	^ self new
		extract: anInterval
		to: aString
		from: aSelector
		in: aClass
]

{ #category : 'api' }
RBExtractToTemporaryTransformation class >> model: aRBNamespace extract: anInterval to: aString from: aSelector in: aClass [
	^ self new
		model: aRBNamespace;
		extract: anInterval
		to: aString
		from: aSelector
		in: aClass;
		yourself
]

{ #category : 'preconditions' }
RBExtractToTemporaryTransformation >> applicabilityPreconditions [ 
	^(RBCondition definesSelector: selector in: class)
		& (RBCondition isValidInstanceVariableName: newVariableName for: class)
			& (RBCondition withBlock:
						[self verifySelectedInterval.
						self checkVariableName.
						true])
]

{ #category : 'executing' }
RBExtractToTemporaryTransformation >> buildTransformations [

	^ self insertTemporary
]

{ #category : 'preconditions' }
RBExtractToTemporaryTransformation >> checkVariableName [
	(class whoDefinesInstanceVariable: newVariableName) ifNotNil:
			[self refactoringError: ('<1p> defines an instance variable named <2s>'
						expandMacrosWith: class
						with: newVariableName)].
	(class whoDefinesClassVariable: newVariableName) ifNotNil:
			[self refactoringError: ('<1p> defines a class variabled named <2s>'
						expandMacrosWith: class
						with: newVariableName)].
	(self parseTree allDefinedVariables includes: newVariableName)
		ifTrue:
			[self refactoringError: ('<1s> is already a temporary variable name'
						expandMacrosWith: newVariableName)]
]

{ #category : 'transforming' }
RBExtractToTemporaryTransformation >> constructAssignmentFrom: aNode [
	| valueNode |
	valueNode := RBVariableNode named: newVariableName.
	"Use a copy so aNode retains its original parent.
	In this case the caller is done making use of the parent backlink,
	but it seems sensible to keep it intact whenever possible."
	^RBAssignmentNode variable: valueNode value: aNode copy.
]

{ #category : 'api' }
RBExtractToTemporaryTransformation >> extract: anInterval to: aString from: aSelector in: aClass [
	class := self model classObjectFor: aClass.
	selector := aSelector.
	sourceInterval := anInterval.
	newVariableName := aString
]

{ #category : 'executing' }
RBExtractToTemporaryTransformation >> insertTemporary [

	^ { (RBCustomTransformation model: self model with: [ :rbMode |
		   | node statementNode nodeReferences |
		   node := self nodeContainedBy: sourceInterval.
		   nodeReferences := self referencesTo: node.
		   statementNode := node statementNode.
		   statementNode parent
			   addNode: (self constructAssignmentFrom: node)
			   before: statementNode;
			   addTemporaryNamed: newVariableName.
		   nodeReferences do: [ :each |
			   each replaceWith: (RBVariableNode named: newVariableName) ].
		   class compileTree: self parseTree ]) }
]

{ #category : 'accessing' }
RBExtractToTemporaryTransformation >> nodeContainedBy: anInterval [
	| node |
	node := self parseTree whichNodeIsContainedBy: anInterval.
	(node notNil and: [ node isValue ])
		ifFalse: [ self refactoringError: 'Cannot assign to non-value nodes' ].
	^ node
]

{ #category : 'accessing' }
RBExtractToTemporaryTransformation >> parseTree [

	parseTree
		ifNil: [
			parseTree := class parseTreeForSelector: selector.
			parseTree ifNil: [ self refactoringError: 'Could not parse method' ]
		].
	^ parseTree doSemanticAnalysis
]

{ #category : 'accessing' }
RBExtractToTemporaryTransformation >> referencesTo: aNode [

	^ aNode methodOrBlockNode allChildren select: [ :each | each = aNode ]
]

{ #category : 'accessing' }
RBExtractToTemporaryTransformation >> selectedSource [

	| source |

	source := class sourceCodeFor: selector.
	source ifNil: [ self refactoringError: 'Couldn''t find sources' ].
	( ( sourceInterval first between: 1 and: source size )
		and: [ sourceInterval last between: 1 and: source size ] )
		ifFalse: [ self refactoringError: 'Invalid interval' ].
	^ source copyFrom: sourceInterval first to: sourceInterval last
]

{ #category : 'printing' }
RBExtractToTemporaryTransformation >> storeOn: aStream [
	aStream nextPut: $(.
	self class storeOn: aStream.
	aStream
		nextPutAll: ' extract: ';
		nextPutAll: sourceInterval asString ;
		nextPutAll: ' to: ';
		nextPutAll: newVariableName;
		nextPutAll: ' from: ';
		nextPutAll: selector;
		nextPutAll: ' in: ';
		nextPutAll: class name.
	aStream nextPut: $)
]

{ #category : 'preconditions' }
RBExtractToTemporaryTransformation >> verifySelectedInterval [
	| selectedParseTree selectedSources |
	selectedSources := self selectedSource.
	selectedParseTree := self parserClass
		parseExpression: selectedSources
		onError: [ :message :position | self refactoringError: 'Invalid selection' ].
	selectedParseTree isSequence
		ifTrue: [ self refactoringError: 'Cannot assign temp to multiple statements' ]
]
