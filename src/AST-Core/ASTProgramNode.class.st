"
ASTProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.

Subclasses must implement the following messages:
	accessing
		start
		stop
	visitor
		acceptVisitor:
	testing
		isFaulty

The #start and #stop methods are used to find the source that corresponds to this node. ""source copyFrom: self start to: self stop"" should return the source for this node.

The #acceptVisitor: method is used by ASTProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.

The #isFaulty method is used to distinguish between valid nodes and nodes created from an invalid source Smalltalk code. For example, code parsed with ASTParsers #parseFaultyExpression: or #parseFaultyMethod:.

Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.

Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.

Instance Variables:
	properties	<Dictionary of: Symbol -> Object>	A set of properties set to this node, for example every node can have the Property #comment to attach the method comment or the comment of the code line this node represents. Other classes or tools may add more type of properties; for example, the reflectivity support adds properties for managing Metalinks. 
	parent	<ASTProgramNode>	the node we're contained in

Class Variables:
	FormatterClass	<Behavior>	the formatter class that is used when we are formatted

"
Class {
	#name : #ASTProgramNode,
	#superclass : #ASTNode,
	#instVars : [
		'parent',
		'properties'
	],
	#classVars : [
		'FormatterClass'
	],
	#category : #'AST-Core-Nodes'
}

{ #category : #accessing }
ASTProgramNode class >> formatterClass [
	^ FormatterClass ifNil: [ ASTSimpleFormatter ] ifNotNil: [ FormatterClass ]
]

{ #category : #accessing }
ASTProgramNode class >> formatterClass: aClass [
	FormatterClass := aClass
]

{ #category : #testing }
ASTProgramNode class >> isAbstract [

	^ self == ASTProgramNode
]

{ #category : #accessing }
ASTProgramNode class >> optimizedSelectors [
	^ #( and: caseOf: caseOf:otherwise: ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue: ifTrue:ifFalse: or: to:by:do: to:do: whileFalse whileFalse: whileTrue whileTrue: )
]

{ #category : #accessing }
ASTProgramNode class >> resetFormatter [

	self formatterClass: nil
]

{ #category : #replacing }
ASTProgramNode >> addReplacement: aStringReplacement [
	parent ifNil: [^self].
	parent addReplacement: aStringReplacement
]

{ #category : #accessing }
ASTProgramNode >> allArgumentVariables [
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allArgumentVariables;
				yourself]
]

{ #category : #iterating }
ASTProgramNode >> allChildren [
	| children |
	children := OrderedCollection new.
	self nodesDo: [ :each | children addLast: each ].
	^ children
]

{ #category : #accessing }
ASTProgramNode >> allComments [
	"Answer a collection of objects representing the comments in the method. Return an empty collection if the method's source code does not contain a comment."

	^ self allChildren flatCollect: [:el| el comments]
]

{ #category : #accessing }
ASTProgramNode >> allDefinedVariables [
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allDefinedVariables;
				yourself]
]

{ #category : #accessing }
ASTProgramNode >> allParents [
	"return all my parents. 
	See discussion in issue https://github.com/pharo-project/pharo/issues/6278"
	^ parent 
		ifNil: [ OrderedCollection new ]
		ifNotNil: [ parent withAllParents ]
]

{ #category : #accessing }
ASTProgramNode >> allStatements [
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allStatements;
				yourself]
]

{ #category : #accessing }
ASTProgramNode >> allTemporaryVariables [
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allTemporaryVariables;
				yourself]
]

{ #category : #accessing }
ASTProgramNode >> allVariables [
	"Return all the variables in subnodes"

	^ self allChildren select: [ :each | each isVariable ]
]

{ #category : #accessing }
ASTProgramNode >> asReturn [
	"Change the current node to a return node."

	parent ifNil: [self error: 'Cannot change to a return without a parent node.'].
	parent isSequence 
		ifFalse: [self error: 'Parent node must be a sequence node.'].
	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].
	^parent addReturn
]

{ #category : #querying }
ASTProgramNode >> assignmentNodes [
	^self allChildren select: [:each | each isAssignment].
]

{ #category : #testing }
ASTProgramNode >> assigns: aVariableName [ 
	^self children anySatisfy: [:each | each assigns: aVariableName]
]

{ #category : #querying }
ASTProgramNode >> bestNodeFor: anInterval [ 
	| selectedChildren selectedComments |
	anInterval ifNil: [^nil ].
	selectedComments := self getCommentsFor: anInterval.
	(self intersectsInterval: anInterval) ifFalse: [^selectedComments ifNil: [ nil ] ifNotNil: [ selectedComments size = 1 ifTrue: [ selectedComments first ] ifFalse: [ nil ] ] ].
	(self containedBy: anInterval) ifTrue: [^self].
	
	selectedChildren := self children select: [:each | 
		each intersectsInterval: anInterval
	].

	^ selectedChildren size = 1 
		ifTrue: [ selectedChildren first bestNodeFor: anInterval ]
		ifFalse: [ (selectedChildren isEmpty and: [ selectedComments size = 1 ])
							ifTrue: [ selectedComments first ]
							ifFalse: [ self ] ]
]

{ #category : #querying }
ASTProgramNode >> bestNodeForPosition: aPosition [

	"aPosition is an integer that represents the position of the caret. 
	A value of N represents that the caret is between the characters N-1 and N.
	The position 1 is at beginning of the text.
	
	Position Heuristic: If the previous character is not a separator, take selection one position before.
		This heuristic is for the cases where the caret (|) is:
		   |self foo  => the caret is before self, do not move
		   self foo|  => the caret is before foo, interpret is as if we are in foo.
			self foo | => the caret is before a space, interpret is as if we are in foo.

		This heuristic introduces although an ambiguity when code is not nicely formatted:
		   self foo:|#bar => Here a user may want foo: or bar.
		For now we decided to favor foo: to motivate people to indent code correctly	"

	| offset position precededBySeparator |
	precededBySeparator := [ 
	                       (aPosition
		                        between: 2
		                        and: self methodNode sourceCode size + 1) 
		                       and: [ 
		                       (self methodNode sourceCode at: aPosition - 1)
			                       isSeparator ] ].
	offset := (aPosition = 1 or: precededBySeparator)
		          ifTrue: [ 0 ]
		          ifFalse: [ -1 ].

	position := aPosition + offset min: self stop.

	^ self bestNodeFor: (position to: position)
]

{ #category : #querying }
ASTProgramNode >> blockNodes [
	^self allChildren select: [:each | each isBlock].
]

{ #category : #accessing }
ASTProgramNode >> blockVariables [
	^parent ifNil: [#()] ifNotNil: [parent blockVariables]
]

{ #category : #'testing - matching' }
ASTProgramNode >> canMatchMethod: aCompiledMethod [ 
	^self sentMessages allSatisfy: 
			[:each | 
			(self class optimizedSelectors includes: each) 
				or: [aCompiledMethod refersToLiteral: each]]
]

{ #category : #'accessing - meta variable' }
ASTProgramNode >> cascadeListCharacter [
	^$;
]

{ #category : #accessing }
ASTProgramNode >> children [
	^#()
]

{ #category : #replacing }
ASTProgramNode >> clearReplacements [
	parent ifNil: [^self].
	parent clearReplacements
]

{ #category : #enumeration }
ASTProgramNode >> collect: aBlock [ 
	"Hacked to fit collection protocols"

	^aBlock value: self
]

{ #category : #accessing }
ASTProgramNode >> comments [
	"Answer the comments of the receiving parse tree node"
	
	^ (self propertyAt: #comments ifAbsent: [ #() ]) ifNil:[ #() ]
]

{ #category : #accessing }
ASTProgramNode >> comments: aCollection [

	(aCollection ifNil: [#()])
		ifEmpty: [ self removeProperty: #comments ifAbsent: [] ] 
		ifNotEmpty: [ self propertyAt: #comments put: aCollection ].
]

{ #category : #testing }
ASTProgramNode >> containedBy: anInterval [ 
	^anInterval first <= self start and: [anInterval last >= self stop]
]

{ #category : #testing }
ASTProgramNode >> containsReturn [
	^self children anySatisfy: [:each | each containsReturn]
]

{ #category : #copying }
ASTProgramNode >> copyCommentsFrom: aNode [ 
	"Add all comments from aNode to us. If we already have the comment, then don't add it."

	| newComments |
	newComments := OrderedCollection new.
	aNode nodesDo: [:each | newComments addAll: each comments].
	self nodesDo: 
			[:each | 
			each comments do: [:comment | newComments remove: comment ifAbsent: []]].
	newComments isEmpty ifTrue: [^self].
	newComments := newComments asSortedCollection: [:a :b | a start < b start].
	self comments: newComments
]

{ #category : #matching }
ASTProgramNode >> copyInContext: aDictionary [
	^ self copy
]

{ #category : #matching }
ASTProgramNode >> copyList: matchNodes inContext: aDictionary [ 
	| newNodes |
	newNodes := OrderedCollection new.
	matchNodes do: 
			[:each | 
			| object |
			object := each copyInContext: aDictionary.
			newNodes addAll: object].
	^newNodes
]

{ #category : #accessing }
ASTProgramNode >> debugHighlightRange [

	^ self debugHighlightStart to: self debugHighlightStop
]

{ #category : #accessing }
ASTProgramNode >> debugHighlightStart [

	^ self start
]

{ #category : #accessing }
ASTProgramNode >> debugHighlightStop [

	^ self stop
]

{ #category : #testing }
ASTProgramNode >> defines: aName [
	^false
]

{ #category : #testing }
ASTProgramNode >> directlyUses: aNode [
	^true
]

{ #category : #enumeration }
ASTProgramNode >> do: aBlock [ 
	"Hacked to fit collection protocols"

	aBlock value: self
]

{ #category : #generation }
ASTProgramNode >> dump [
	"Generate a literal expression that recreates the receiver"

	| visitor |
	visitor := ASTDumpVisitor new.
	self acceptVisitor: visitor.
	^ visitor contents
]

{ #category : #comparing }
ASTProgramNode >> equalTo: aNode exceptForVariables: variableNameCollection [ 
	| dictionary |
	dictionary := Dictionary new.
	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].
	dictionary keysAndValuesDo: 
			[:key :value | 
			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].
	^true
]

{ #category : #comparing }
ASTProgramNode >> equalTo: aNode withMapping: aDictionary [ 
	^self = aNode
]

{ #category : #testing }
ASTProgramNode >> evaluatedFirst: aNode [ 
	self children do: 
			[:each | 
			each == aNode ifTrue: [^true].
			each isImmediateNode ifFalse: [^false]].
	^false
]

{ #category : #accessing }
ASTProgramNode >> formattedCode [
	^ self formatterClass new format: self
]

{ #category : #accessing }
ASTProgramNode >> formatterClass [
	^ self class formatterClass
]

{ #category : #querying }
ASTProgramNode >> getCommentsFor: anInterval [
	| selectedComments |
	selectedComments := OrderedCollection new.
	self nodesDo: 
		[ :each | 
			| comments | 
			comments := each comments select: 
				[ :com | com intersectsInterval: anInterval ]. 
	"This precaution is taken to deal with cascades multiple visit of the receiver."
			(selectedComments isNotEmpty 
				and: [ comments isNotEmpty 
				and: [ comments last = selectedComments last ]]) 
					ifFalse: [selectedComments addAll: comments ] ].
	^ selectedComments
]

{ #category : #testing }
ASTProgramNode >> hasComments [
	"Answer whether the receiver as comments"
	
	^ self comments isNotEmpty
]

{ #category : #testing }
ASTProgramNode >> hasMultipleReturns [
	| count |
	count := 0.
	self nodesDo: [:each | each isReturn ifTrue: [count := count + 1]].
	^count > 1
]

{ #category : #properties }
ASTProgramNode >> hasProperty: aKey [
	"Test if the property aKey is present."
	
	^ properties notNil and: [ properties includesKey: aKey ]
]

{ #category : #comparing }
ASTProgramNode >> hashForCollection: aCollection [
	^ aCollection isEmpty ifTrue: [ 0 ] ifFalse: [ aCollection first hash ]
]

{ #category : #querying }
ASTProgramNode >> instanceVariableNodes [
		^self variableNodes select: [:each | each isInstanceVariable]
]

{ #category : #querying }
ASTProgramNode >> instanceVariableReadNodes [
		^self variableReadNodes select: [:each | each isInstanceVariable]
]

{ #category : #querying }
ASTProgramNode >> instanceVariableWriteNodes [
		^self variableWriteNodes select: [:each | each isInstanceVariable]
]

{ #category : #testing }
ASTProgramNode >> intersectsInterval: anInterval [ 
	^(anInterval first between: self start and: self stop) 
		or: [self start between: anInterval first and: anInterval last]
]

{ #category : #testing }
ASTProgramNode >> isArgumentVariable [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isArrayError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isAssignment [
	^false
]

{ #category : #testing }
ASTProgramNode >> isBlockError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isCascade [
	^false
]

{ #category : #testing }
ASTProgramNode >> isClassVariable [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isCommentNode [
	^false
]

{ #category : #testing }
ASTProgramNode >> isDirectlyUsed [
	"This node is directly used as an argument, receiver, or part of an assignment."

	^parent ifNil: [false] ifNotNil: [parent directlyUses: self]
]

{ #category : #testing }
ASTProgramNode >> isDynamicArray [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isEnglobingError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isEvaluatedFirst [
	"Return true if we are the first thing evaluated in this statement."

	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]
]

{ #category : #testing }
ASTProgramNode >> isFaulty [
	"return true if the AST contains a RBParseErrorNode"
	^false
]

{ #category : #testing }
ASTProgramNode >> isGlobalVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isHaltNode [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isImmediateNode [
	^false
]

{ #category : #testing }
ASTProgramNode >> isInstanceVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLast: aNode [ 
	| children |
	children := self children.
	^children notEmpty and: [children last == aNode]
]

{ #category : #'testing - matching' }
ASTProgramNode >> isList [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLiteralArray [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLiteralArrayError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLiteralNode [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLiteralVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isLocalVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isMessage [
	^false
]

{ #category : #testing }
ASTProgramNode >> isMethod [
	^false
]

{ #category : #testing }
ASTProgramNode >> isParenthesesError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isParseError [
	^false
]

{ #category : #'testing - matching' }
ASTProgramNode >> isPatternNode [
	^false
]

{ #category : #testing }
ASTProgramNode >> isPragma [
	^false
]

{ #category : #testing }
ASTProgramNode >> isPragmaError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isReservedVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isReturn [
	^false
]

{ #category : #testing }
ASTProgramNode >> isSelector [
	^false
]

{ #category : #testing }
ASTProgramNode >> isSelfOrSuperVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isSelfVariable [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isSequence [
	^false
]

{ #category : #testing }
ASTProgramNode >> isSuperVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isTempVariable [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isTemporariesError [
	^false
]

{ #category : #testing }
ASTProgramNode >> isThisContextVariable [
	^ false
]

{ #category : #testing }
ASTProgramNode >> isUndeclaredVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isUnfinishedStatement [
	^false
]

{ #category : #testing }
ASTProgramNode >> isUsed [
	"Answer true if this node could be used as part of another expression. For example, you could use the 
	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 
	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 
	return values of blocks."

	^parent ifNil: [false] ifNotNil: [parent uses: self]
]

{ #category : #testing }
ASTProgramNode >> isValue [
	^false
]

{ #category : #testing }
ASTProgramNode >> isVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> isWorkspaceVariable [
	^false
]

{ #category : #testing }
ASTProgramNode >> lastIsReturn [
	^self isReturn
]

{ #category : #'accessing - meta variable' }
ASTProgramNode >> listCharacter [
	^$@
]

{ #category : #'accessing - meta variable' }
ASTProgramNode >> literalCharacter [
	^$#
]

{ #category : #accessing }
ASTProgramNode >> mappingFor: aNode [
	| method |
	method := self methodNode.
	method ifNil: [^aNode].
	^method mappingFor: aNode
]

{ #category : #matching }
ASTProgramNode >> match: aNode inContext: aDictionary [ 
	^ self = aNode
]

{ #category : #matching }
ASTProgramNode >> matchList: matchNodes against: programNodes inContext: aDictionary [ 
	^self
		matchList: matchNodes
		index: 1
		against: programNodes
		index: 1
		inContext: aDictionary
]

{ #category : #matching }
ASTProgramNode >> matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary [ 
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].
	node := matchNodes at: matchIndex.
	node isList 
		ifTrue: 
			[currentIndex := programIndex - 1.
			
			[currentDictionary := aDictionary copy.
			programNodes size < currentIndex or: 
					[nodes := programNodes copyFrom: programIndex to: currentIndex.
					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 
							[(self 
								matchList: matchNodes
								index: matchIndex + 1
								against: programNodes
								index: currentIndex + 1
								inContext: currentDictionary) 
									ifTrue: 
										[currentDictionary 
											keysAndValuesDo: [:key :value | aDictionary at: key put: value].
										^true].
							false]]] 
					whileFalse: [currentIndex := currentIndex + 1].
			^false].
	programNodes size < programIndex ifTrue: [^false].
	(node match: (programNodes at: programIndex) inContext: aDictionary) 
		ifFalse: [^false].
	^self 
		matchList: matchNodes
		index: matchIndex + 1
		against: programNodes
		index: programIndex + 1
		inContext: aDictionary
]

{ #category : #accessing }
ASTProgramNode >> methodNode [
	^parent ifNotNil: [parent methodNode]
]

{ #category : #accessing }
ASTProgramNode >> methodOrBlockNode [
	^ parent ifNotNil: [ parent methodOrBlockNode ]
]

{ #category : #accessing }
ASTProgramNode >> newSource [
	^self formattedCode
]

{ #category : #'node access' }
ASTProgramNode >> nodeForOffset: anInteger [
	| children |
	"choosing the best node on the specific offset"
	children := self children.
	"when we are on a leaf, we take the leaf node"
	(children isEmpty) ifTrue: [ (self sourceInterval includes: anInteger) ifTrue: [^self]].
	"if the node has children then we check the children"
	children do: [:each | (each sourceInterval includes: anInteger) ifTrue: [^each nodeForOffset: anInteger] ].
]

{ #category : #iterating }
ASTProgramNode >> nodesDo: aBlock [ 
	aBlock value: self.
	self children do: [ :each | each nodesDo: aBlock ]
]

{ #category : #accessing }
ASTProgramNode >> parent [
	^parent
]

{ #category : #accessing }
ASTProgramNode >> parent: anASTProgramNode [ 
	parent := anASTProgramNode
]

{ #category : #hook }
ASTProgramNode >> parserClass [
	^ ASTParser
]

{ #category : #copying }
ASTProgramNode >> postCopy [
	super postCopy.
	properties := properties copy
]

{ #category : #accessing }
ASTProgramNode >> precedence [
	^6
]

{ #category : #printing }
ASTProgramNode >> printOn: aStream [ 
	aStream
		nextPutAll: self class name;
		nextPut: $(;
		nextPutAll: self formattedCode;
		nextPut: $)
]

{ #category : #properties }
ASTProgramNode >> propertyAt: aKey [
	"Answer the property value associated with aKey."
	
	^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]
]

{ #category : #properties }
ASTProgramNode >> propertyAt: aKey ifAbsent: aBlock [
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."
	
	^ properties 
		ifNil: aBlock
		ifNotNil: [ properties at: aKey ifAbsent: aBlock ]
]

{ #category : #properties }
ASTProgramNode >> propertyAt: aKey ifAbsentPut: aBlock [
	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."
	
	^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]
]

{ #category : #properties }
ASTProgramNode >> propertyAt: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock [
	"Answer the property value associated with aKey or, if aKey is found, answer the result of evaluating aPresentBlock, else evaluates anAbsentBlock."

	^ properties ifNil: anAbsentBlock ifNotNil: [ properties at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock ]
]

{ #category : #properties }
ASTProgramNode >> propertyAt: aKey put: anObject [
	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."

	^ (properties ifNil: [ properties := SmallDictionary new: 1 ])
		at: aKey put: anObject
]

{ #category : #'testing - matching' }
ASTProgramNode >> recurseInto [
	^false
]

{ #category : #'accessing - meta variable' }
ASTProgramNode >> recurseIntoCharacter [
	^$`
]

{ #category : #testing }
ASTProgramNode >> references: aVariableName [ 
	^self children anySatisfy: [:each | each references: aVariableName]
]

{ #category : #replacing }
ASTProgramNode >> removeDeadCode [
	self children do: [:each | each removeDeadCode]
]

{ #category : #properties }
ASTProgramNode >> removeProperty: aKey [
	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."
	
	^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].
]

{ #category : #properties }
ASTProgramNode >> removeProperty: aKey ifAbsent: aBlock [
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| answer |
	properties ifNil: [ ^ aBlock value ].
	answer := properties removeKey: aKey ifAbsent: aBlock.
	properties isEmpty ifTrue: [ properties := nil ].
	^ answer
]

{ #category : #replacing }
ASTProgramNode >> replaceMethodSource: aNode [ 
	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."

	| method |
	method := self methodNode.
	method notNil ifTrue: [method map: self to: aNode].
	aNode parent: self parent.
	[self replaceSourceWith: aNode] on: Error
		do: 
			[:ex | 
			self clearReplacements.
			ex return]
]

{ #category : #replacing }
ASTProgramNode >> replaceNode: aNode withNode: anotherNode [ 
	self error: 'I don''t store other nodes'
]

{ #category : #'private - replacing' }
ASTProgramNode >> replaceSourceFrom: aNode [
	self == aNode
		ifFalse: [ self clearReplacements ]
]

{ #category : #'private - replacing' }
ASTProgramNode >> replaceSourceWith: aNode [ 
	aNode replaceSourceFrom: self
]

{ #category : #replacing }
ASTProgramNode >> replaceWith: aNode [ 
	parent ifNil: [self error: 'This node doesn''t have a parent'].
	self replaceMethodSource: aNode.
	parent replaceNode: self withNode: aNode
]

{ #category : #enumeration }
ASTProgramNode >> reverseNodesDo: aBlock [ 
	self children reverseDo: [ :each | each reverseNodesDo: aBlock ].
	aBlock value: self
]

{ #category : #querying }
ASTProgramNode >> selfMessages [
	^(self sendNodes select: [ :node | node isSelfSend ] thenCollect: [ :node | node selector ]) asSet
]

{ #category : #accessing }
ASTProgramNode >> sendNodes [
	^self allChildren select: [:each | each isMessage].
]

{ #category : #accessing }
ASTProgramNode >> sentMessages [
	^ self children
		inject: Set new
		into: [ :messages :each | 
			messages
				addAll: each sentMessages;
				yourself ]
]

{ #category : #enumeration }
ASTProgramNode >> size [
	"Hacked to fit collection protocols"

	^1
]

{ #category : #accessing }
ASTProgramNode >> source [
	^ parent notNil ifTrue: [ parent source ] ifFalse: [ nil ]
]

{ #category : #accessing }
ASTProgramNode >> sourceCode [

	| interval |
	interval := self sourceInterval.
	interval ifEmpty: [ ^ '' ].
	
	^ self source 
		copyFrom: interval first
		to: interval last
]

{ #category : #accessing }
ASTProgramNode >> sourceInterval [
	^ self start to: self stop
]

{ #category : #accessing }
ASTProgramNode >> start [
	self subclassResponsibility
]

{ #category : #'accessing - meta variable' }
ASTProgramNode >> statementCharacter [
	^$.
]

{ #category : #accessing }
ASTProgramNode >> statementComments [
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	self children do: [:each | statementComments addAll: each statementComments].
	^statementComments asSortedCollection: [:a :b | a start < b start]
]

{ #category : #querying }
ASTProgramNode >> statementNode [
	"Return your topmost node that is contained by a sequence node."

	(parent isNil or: [parent isSequence]) ifTrue: [^self].
	^parent statementNode
]

{ #category : #accessing }
ASTProgramNode >> statements [
	^ #()
]

{ #category : #accessing }
ASTProgramNode >> stop [
	self subclassResponsibility
]

{ #category : #querying }
ASTProgramNode >> superMessages [
	^(self sendNodes select: [ :node | node isSuperSend ] thenCollect: [ :node | node selector ]) asSet
]

{ #category : #querying }
ASTProgramNode >> tempVariableReadNodes [
		^self variableReadNodes select: [:each | each isTempVariable]
]

{ #category : #accessing }
ASTProgramNode >> temporaryVariables [
	^parent ifNil: [#()] ifNotNil: [parent temporaryVariables]
]

{ #category : #testing }
ASTProgramNode >> uses: aNode [
	^true
]

{ #category : #querying }
ASTProgramNode >> variableDefinitionNodes [
	^ self allChildren select: [ :each | 
		  each isVariable and: [ each isDefinition ] ]
]

{ #category : #querying }
ASTProgramNode >> variableNodes [

	^ self allChildren select: [ :each | 
		  each isVariable and: [ each isDefinition not ] ]
]

{ #category : #querying }
ASTProgramNode >> variableReadNodes [
	^self variableNodes select: [:each | each isRead]
]

{ #category : #querying }
ASTProgramNode >> variableWriteNodes [
		^self variableNodes select: [:each | each isWrite]
]

{ #category : #querying }
ASTProgramNode >> whichNodeIsContainedBy: anInterval [ 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]
		ifFalse: [nil]
]

{ #category : #querying }
ASTProgramNode >> whoDefines: aName [ 
	^(self defines: aName) 
		ifTrue: [self]
		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]
]

{ #category : #accessing }
ASTProgramNode >> withAllParents [
	"return me and all my parents. Topmost parent first, me last
	See discussion in issue https://github.com/pharo-project/pharo/issues/6278"
	^ parent 
		ifNil: [ OrderedCollection with: self ]
		ifNotNil: [ 
			parent withAllParents 
				addLast: self;
				yourself ]
]
