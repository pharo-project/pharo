## Scripting refactorings

This chapter we show how to manually use the refactoring operations.

### Overview

This chapter describes the steps needed to set up an environment and fill in the data
to execute refactoring operations.

This enables you to execute refactorings that aren't provided by the System Browser, or combining a set of operations for a more complex refactoring. It also gives a hint on how to add refactoring support for your own tools.


These are the steps used for all of the examples:
- create a RBNamespace
- instantiate the refactoring operation
- execute it (primitiveExecute)
- open a changes browser to view and apply the changes
  applying the changes will actually execute the code transformations 'for real'.

### A first example

We want to add a new class with the RBAddClassRefactoring. (This is just a simple example, most of the time you won't use a refactoring operation for adding new classes. But it is used by tools generating classes or by other refactoring operations (RBSplitClassRefactoring)).

First we need a namespace, a RBNamespace, it collects the changes generated by this operation and provides an environment for finding other classes / methods affected by the operation.
We create a 'default' RBNamespace that represents an environment of all system classes. The RBAddClassRefactoring needs all the information needed for the class hierarchy (name/superclass/subclasses/category) and our namespace as the 'model'. The ChangesBrowser lists all the refactoring changes in a check box list. The reason for calling 'changes changes' not the model is, because the first 'changes' does not give a list of all changes but a RBCompositeRefactoryChange that actually holds the list of all changes.

```
  | model addClassRB browser |
    model := RBNamespace new.
    addClassRB := RBAddClassRefactoring
        model: model
        addClass: #SomeClass
        superclass: #Object
        subclasses: {}
        category: #Category.
    addClassRB primitiveExecute.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open
```

Keep in mind that some compound refactorings may not show all intermediate changes.

The `primitiveExecute` method will check all preconditions for this Refactoring and either shows a warning or a refactoring error, if this operation can not be performed.
We can execute the above refactoring 'twice' and will see the second time it shows an error about SomeClass already exists.

There is a global change manager - `RBRefactoryChangeManager`, we can use it to undo the last operation.

```
RBRefactoryChangeManager instance undoOperation.
```
and again redo

```
RBRefactoryChangeManager instance redoOperation.
```
and undo, and .... :)


### Combining operations - Add class with instance variables

As we saw, the `RBAddClassRefactoring` does not allow us to define any instance variables. Instead we can add a new class and then apply another refactoring, `RBAddInstanceVariableRefactoring`.
We just need to call them in the appropriate order and make sure that both operations operate on the same model - otherwise the instance variable refactoring would not know about the class it should operate on.

```
| model addClassRB addInstVarsRB browser |
model := RBNamespace new.
addClassRB := RBAddClassRefactoring
      model: model
      addClass: #SomeClass
      superclass: #Object
      subclasses: {}
      category: #Category.
addClassRB primitiveExecute.
addInstVarsRB := RBAddInstanceVariableRefactoring
    model: model
    variable: 'x'
    class: #SomeClass.
addInstVarsRB primitiveExecute.
```
```
    browser := ChangesBrowser new.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open
```

It is important to actually execute the first operation before creating the second one. The instantiation of the RBAddInstanceVariableRefactoring will query the environment the class #SomeClass and
init the reference to nil if it doesn't yet exists.

The changes browser now includes two refactorings, you can select only the second one but this won't work.
If you applied both, and want to undo that changes, you'll need to call two times:
RBRefactoryChangeManager instance undoOperation.

### Scoping Refactoring

A refactoring operation often changes existing code by first, search for a pattern, and then transform the matching code into the new form. But in some situations you don't want to apply the change to all found matches.
For example, you want to rename a method in all implementors and all callers of your package. If this method name is a common message in other (system) classes as well, you don't want to rename all places and for sure you don't want to go through the ChangesBrowser and unselect all those matches by hand.

We can restrict the search space by creating our namespace from a restricted browser environment.
(More about restricted environments in the chapter RBBrowserEnvironments)

In this example we will apply the RBPrettyPrintCodeRefactoring to all classes in the Package 'Tests', by first creating a RBBrowserEnvironment for packages and then create the RBNamespace with this environment:

```
 | env model prettyPrintRB browser |
    env := RBBrowserEnvironment new forPackageNames:{'Tests'}.
    model := RBNamespace onEnvironment: env.
    prettyPrintRB := RBPrettyPrintCodeRefactoring new model: model; yourself.
    prettyPrintRB primitiveExecute.
    browser := ChangesBrowser new.
    browser := ChangesBrowser changes: (model changes changes ).
    browser open
```

After applying this refactoring, all methods in all classes of the package 'Tests' will be reformatted (pretty print).

### Refactoring Options

Some refactoring operations may require additional informations for performing the transformation. For example a 'move method ' refactoring, moving a method from one class to another may add an additional argument if the prior method had some 'self sends'. Some of the information are given by instantiating the refactoring and some information can be computed by the
operation itself. For other cases the refactoring may actually break code or create broken code. To make this operation still work the programmer or user of the refactoring engine
could provide the needed information. 

For this, the engine contains a set of 'options' that can be set by the tool using the framework, to register callback functions used to aquire the information from the user.

The options that can be used are:

- #implementorToInline - select one of a list of method names
- #methodName - ask for a method name
- #selfArgumentName - argument name to use for replacing self sends
- #selectVariableToMoveTo - select one of a list of variable names
- #variableTypes - select or provide a class
- #extractAssignment - should the code extraction include the variable assignment
- #inlineExpression - I don't know
- #alreadyDefined - Should it override  methods defined in the hierarchy.
- #useExistingMethod - Should it use existing (equivalent) method
- #openBrowser - call to open system browser

A tool now can register a callback like

```
refactoring 
	setOption:#name_of_an_option 
	toUse:[:a :b: ... a block with needed arguments]
```

for example, Calypso sets the option `#implementorToInline` to a method showing a dialog with a list to choose one of the provided selector names.


### Example

In the following example we show how to set the needed options manually. The RBMoveMethodRefactoring will ask us three questions
- selfArgumentName
- variableTypes
- methodName

for all of this options we set a simple block that just returns the information needed for this example task. In a real world tool, we
would need some interactive tool to let the user make a choice.
This `RBMoveMethodRefactoring` will move the implementation from `TestResult class>>#historyFor:` to its argument of type `TestCase`.

```
    | model rbMoveMethod browser |
    model := RBNamespace onEnvironment: RBBrowserEnvironment new.
    rbMoveMethod := RBMoveMethodRefactoring
        model: model
        selector: #historyFor:
        class: TestResult class
        variable: 'aTestCaseClass'.
    rbMoveMethod setOption: #selfArgumentName toUse: [ :ref | 'aResultClass' ].
    rbMoveMethod
        setOption: #variableTypes
        toUse: [ :ref :types :selected | {(model classNamed: #TestCase)} ].
    rbMoveMethod
        setOption: #methodName
        toUse: [ :ref :name | RBMethodName selector: 'asHistoryFor:' arguments: {'aTestResult'} ].
    rbMoveMethod primitiveExecute.
    browser := ChangesBrowser changes: model changes changes.
    browser open
```

The result of this operation is, the method #historyFor: is moved to the class TestCase and the former implementation is replaced by
```
aTestCase asHistoryFor: self
```

as the former implementation had a call to self (self newTestDictionary) we need to add self as an argument for the new method.
The refactoring operation queries this argument name by calling the registered block for the option `'selfArgumentName'`, as the refactoring can not guess the type of the class we want to move the method, it will ask us by calling 'variableTypes' and finally the new method name and arguments are provided by calling the block for option `'methodName'`.
