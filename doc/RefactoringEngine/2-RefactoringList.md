## Default refactorings exposed to the user

Most refactoring operations fall into one of three categories: class, method and method source level refactorings. Depending on the kind of Refactoring (Class/Method/Source) you can find and apply the refactoring from the "Refactoring" Menu on the class-, method- or code-pane.

Executing a refactoring will open a changes browser that lets you see and (depending on the current operation) select which change to apply.
If the refactoring can not be applied, because one of its preconditions aren't met (for example you try to rename a class with a name that is already used), a warning message appears. The refactoring changes will be applied to all classes and methods in the current "namespace". For the default system browser, this is the whole system. If you want to restrict the operation to some set of classes or packages, you can open a system browser on a refactoring environmet - a kind of "scoped view".

Example:

```st
(RBBrowserEnvironment default forPackageNames: {'Kernel'}) browse. 
```

will open a system browser with only the classes from package 'Kernel'. And all refactoring operations will only find and change classes in this selection.

Here is a list generated from the Refactoring class comments describing the refactorings available. 

### Class Refactorings

This is the chapter of the refactoring help book about the class refactoring available in the System Browser.

#### Rename
I am a refactoring for renaming a class.

My preconditions verify, that the old class exists (in the current namespace) and that the new class name is valid and not yet used as a global variable name 

The refactoring transformation will replace the current class and its definition with the new class name. And update all references in all methods in this namespace, to use the new name. Even the definition for subclasses of the old class will be changed.

Example

```st
(RBRenameClassRefactoring 
	rename: 'RBRenameClassRefactoring' 
	to: 'RBRenameClassRefactoring2') execute
```

#### Remove

I am a refactoring for removing classes.

My precondition verifies that the class name exists in this namespace and the class has no references, resp. users, if this is used to remove a trait.

If this class is "empty" (has no methods and no variables), any subclass is reparented to the superclass of this class. It is not allowed to remove non-empty classes when it has subclasses.

#### Remove keeping subclasses

I am a refactoring for removing classes but keeping subclasses in a safe way.

My precondition verifies that the class name exists in this namespace and the class has no references, resp. users, if this is used to remove a trait.

If this class is "not empty" (has methods and variables), any subclass is reparented to the superclass of this class, and all its methods and variables (instance and class) are push down in its subclasses.

Example
```st
(RBRemoveClassKeepingSubclassesRefactoring classNames: { #RBTransformationRuleTestData1 }) execute. 
```

#### Generate Accessors

Generates setter and getter methods for every instance variable defined in this class. The user is provided with a changes browser dialog allowing to select and unselected the creation of single methods. The name for the accessors is auto-generated by the instance variable name. If a method with this name already exists, the new name will have a incremented counter.

#### Generate Superclass

Adds a new superclass between a class and its previous superclass. It offers a check-box list of the subclasses. Every checked element will be moved to be a subclass of the new superclass. That is, subclasses are moved to siblings of its prior superclass. Every instance variable shared by the new siblings will be moved to the new superclass.
The name of the new class needs to be a valid class name, not yet used as any global identifier.

#### Insert Superclass

Similar to "Generate Superclass", but just generates a new class between a class and its previous superclass. With no change on the subclass hierarchy of the class.
The name of the new class needs to be a valid class name, not yet used as any global identifier.

#### Insert Subclass

Just generate a new class between this class and its subclasses.
The name of the new class needs to be a valid class name, not yet used as any global identifier.

#### Generate Subclass

Adds a new class as a subclass of the selected class. It offers a check box list of the subclasses. Every checked element will be moved to be a sub-subclass of the new subclass. The hierarchy of the not checked elements is unchanged and they become siblings of the new class.
The name of the new class needs to be a valid class name, not yet used as any global identifier.

#### Realize

Complete the set of defined methods of this class, by generating a "self shouldBeImplemented" method for all abstract methods defined in its superclass hierarchy. Where an abstract method is a method sending "self subclassResponsibilty.
Shows a warning if this class has abstract methods on its own.

#### Split

I am a refactoring for extracting a set of instance variables to a new class.

You can choose which instance variables should be moved into the new class. The new class becomes an instvar of the original class and every reference to the moved variables is replaced by a accessor call.

My precondition verifies that the new instance variable is a valid variable name and not yet used in this class or its hierarchy
 the name of the new class representing the set of instance variables is a valid class name

Example:
In the following class the variables color/font/style should be moved to a new `TextAttributesClass`.

```st
Object subclass: #TextKlass
	instanceVariableNames: 'text color font style'
	classVariableNames: ''
	package: 'TestKlasses'
```

We apply the Split Refactoring with these three variables and select a new class name TextAttributes used as variable new "textAttributes".
The class definition will be changed to:

```st
Object subclass: #TextKlass
	instanceVariableNames: 'text textAttributes'
	classVariableNames: ''
	package: 'TestKlasses'
```

and every reference to the old vars color / font / style will be replaced by textAttributes color / textAttributes style / textAttributesFont

### Class and Instance Variable Refactorings

#### Add Variable

I am a refactoring for adding new instance variables.

My precondition verifies that the variable name is valid, not yet used in the whole hierarchy and not a global name.

#### Rename

Shows a list of variables from the class or instance side. The selected variable is renamed in the class definition and in all methods referring to this var. The name of the accessor methods are unchanged.

#### Remove

Shows a list of variables from the class or instance side. The selected variable is removed. If the variable is referred by a method, it asks for opening a browser window, showing only those classes and its methods accessing this variable (a scoped browser view).

#### Abstract

Shows a list of variables from the class or instance side, creates an accessor for the variable and replaces all direct access to this variable by this accessors method.
(For this class and all of its subclasses.)
There is no special handling for already existing accessors methods, their direct access is replaced too. And if an accessors method with the name of this variable already exists, the newly created method will get the same name with a counter suffix.

#### Accessor

Choose one instance / class variable to create accessors for.
A getter and setter methods is generated, with the name of the chosen instance variable. If a method with this name already exists, it will create a new method with the same name and a counter suffix.

#### Accessor with lazy initialization

I am a refactoring for creating accessors with lazy initialization for variables.

I am used by a couple of other refactorings creating new variables and accessors.

My precondition is that the variable name is defined for this class.

Example

```st
(RBCreateAccessorsWithLazyInitializationForVariableRefactoring 
	variable: 'foo1' 
	class: RBLintRuleTestData 
	classVariable: false 
	defaultValue: '123') execute
```

After refactoring we get:
```st
RBLintRuleTestData >> foo1 
	^ foo1 ifNil: [foo1 := 123]
	
RBLintRuleTestData >> foo1: anObject
	foo1 := anObject
```

#### Move to class

Only for instance variables. A class search dialog lets you choose the target class to move the instance variable to.
Another dialog for choosing the instance variable to move. If there are any methods referring to this variable, a message list opens, showing all broken methods.

#### Pull up

Moves an instance/class variable up to the superclass. The variable is added to the superclass and removed from this and all other sibling classes, defining this variable. A warning message appears if not all direct subclasses defined this variable.

#### Push down

Moves an instance/class variable down to the subclasses. The variable is added to every direct subclass.
A warning dialog appears if there are methods referring to this class (accessors methods for example), and offers a choice to open a (scoped) browser for this messages.
No accessors method will be changed or generated.

#### Merge variable

I am a refactoring for merge an instance variable into another.

I replace an instance variable by other, in all methods referring to this variable and rename the old accessors, then if the instance variable renamed is directly defined in class it is removed.

My precondition verifies that the new variable is a defined instance variable in class.

Example

```st
(RBMergeInstanceVariableIntoAnother rename: 'x' to: 'y' in: Foo) execute.
```

Before refactoring:

```st
Class Foo -> inst vars: x, y 

Foo >> foobar
	^ x 

Foo >> foo
	^ x + y 
```

After refactoring merging X into Y

```st
Class Foo -> inst vars: y 

Foo >> foobar
	^ y

Foo >> foo 
	^ y + y
```

### Method Refactorings

#### Add parameter

I am a refactoring operations for adding method arguments.

You can modify the method name and add an additional keyword argument and the default value used by senders of the original method. Only one new argument can be added. But you can change the whole method name, as long as the number of argument matches.

For example, for `r:g:b:`  add another parameter "a" the new method is `r:g:b:a:`
or change the whole method to `setRed:green:blue:alpha:`.

This refactoring will 
- add a new method with the new argument, 
- remove the old method (for all implementors) and 
- replace every sender of the prior method with the new one, using the specified default argument.

#### Deprecate

I am a refactoring for deprecate a method.

My preconditions verify, that the old selector exists (in  the current namespace) and that the new selector is a valid selector.

The refactoring transformation will add the call to the #deprecated:on:in: method

##### Example

```st
(RBDeprecateMethodRefactoring 
	deprecateMethod: #called:on: 
	in: RBRefactoryTestDataApp 
	using: #callFoo) execute
```

Before refactoring:

```st
RBRefactoryTestDataApp >> called: anObject on: aBlock 
	Transcript
		show: anObject printString;
		cr.
	aBlock value
```

After refactoring:

```st
RBRefactoryTestDataApp >> called: anObject on: aBlock 
	self
		deprecated: 'Use #callFoo instead'
		on: '16 April 2021'
		in: 'Pharo-9.0.0+build.1327.sha.a1d951343f221372d949a21fc1e86d5fc2d2be81 (64 Bit)'.
	Transcript
		show: anObject printString;
		cr.
	aBlock value
```

#### Inline parameter

I am a refactoring for removing and inlining method arguments.

If all callers of a method with arguments, call that method with the same literal argument expression, you can remove that argument and inline the literal into that method.

My precondition verifies that the method name without that argument isn't already used and that all callers supplied the same literal expression.

For example, a method `foo: anArg`

```st
foo: anArg
	anArg doSomething.
```

and all senders supply the same argument: 	     

```st
method1
	anObject foo: 'text'.

method2
	anObject foo: 'text'.
```	
the method argument can be inlined:

```st
foo
 | anArg |
 anArg := 'text'.
	anArg doSomething.
```

and the callers just call the method without any arguments:

```st
method1
	anObject foo.
```

#### Inline target sends

I am a refactoring for inlining code of this method.

The call to this method in all other methods of this class is replaced by its implementation. The method itself will be removed.

For example, a method

```st
foo
	^ 'text'
```	
is called in

```st
baz
	| a |
	a := self foo.
	^ self foo.
```	
inlining in all senders replaces the call to method foo, with its code:

```st
baz
	| a |
	a := 'text'.
	^ 'text'.
```

#### Move

I am a refactoring for moving a method from the class to one of its instance variable objects.

Moving a method moves it implementation to one or more classes and replaces the implementation in the original method by a delegation to one of the classes instance variable. 

I expect an option for selecting the type (classes) to which this method should be added.
A role typer RBRefactoryTyper is used to guess the possible classes used for this instance variables.
And an option for requesting the new method selector.

For all selected classes a method implementing the original method is created, and if the original code uses some references to self, a parameter needs to be added to provided the former implementor.

For example, moving the method #isBlack from class Color to its instvar #rgb for the type "Integer" creates a method 


```st
Integer >> isBlack
	 ^ self = 0
```

and changes Colors implementation from:

```st
Color >> isBlack
	^ rgb = 0
```

to:

```st
Color >> isBlack
	^ rgb isBlack
```

#### Move to class side / instance side

Move a method from the class to the instance side, or vice versa. Pay attention this is not a refactoring because there is no update to the method moved.

Only instance methods with no instance variable access or class methods with no class instance variable access can be moved.

##### Move to class side

I'm a refactoring to move a method to class side.

My preconditions verify that the method exists and belongs to instance side.

I catch broken references (method senders and direct access to instVar) and fix them.

Example

```st
(RBMoveMethodToClassSideRefactoring 
	method: (RBTransformationRuleTestData >> #rewriteUsing:) 
	class: RBTransformationRuleTestData) execute.
```

Before refactoring:

```st
RBTransformationRuleTestData >> rewriteUsing: searchReplacer 
     rewriteRule := searchReplacer.
     self resetResult.
```

After refactoring:

```st
RBTransformationRuleTestData >> rewriteUsing: searchReplacer
     ^ self class rewriteUsing: searchReplace.

RBTransformationRuleTestData class >> rewriteUsing: searchReplacer
    | aRBTransformationRuleTestData |
    aRBTransformationRuleTestData := self new.
    aRBTransformationRuleTestData rewriteRule: searchReplacer.
    aRBTransformationRuleTestData resetResult.
```

#### Push up

I am a refactoring for moving a method up to the superclass.

My precondition verify that this method does not reference to instance variables not accessible in the superclass. And this method does not sends a super message that is defined in the superclass.
If the method already exists and the superclass is abstract or not referenced anywhere, replace that implementation and push down the old method to all other existing subclasses.

#### Push down

I am a refactoring for moving a method down to all direct subclasses.

My preconditions verify that this method isn't referred as a super send in the subclass. And the class defining this method is abstract or not referenced anywhere.

#### Remove Method

I am a refactoring for removing a method.

My preconditions verify that this method is not referenced anywhere.

#### Remove parameter

I am a refactoring for removing (unused) arguments.

My preconditions verify that the argument to be removed is not referenced by the methods and that the new method name isn't already used.
Any sender of the prior selector will be changed to the new.

If the method contains more than one argument, I request the user to choose one of the arguments.

#### Remove all senders

I am a refactoring to remove all possible senders from a method (you cannot remove those calls where the result of the method call is used or when the method name symbol is referenced).

#### Example

```st
| refactoring options |
refactoring := RBRemoveSenderRefactoring 
			remove: (90 to: 105) "node position to be removed "
			inMethod: #caller1
			forClass: RBRefactoryTestDataApp.
options := refactoring options copy.
options at: #inlineExpression put: [:ref :string | false].
refactoring options: options.
refactoring execute.
```

Before refactoring:

```st
RBRefactoryTestDataApp >> caller1
	| anObject |
	anObject := 5.
	self called: anObject + 1
		on1: 
			[:each | 
			each printString.
			^anObject]
```

After refactoring (notice that the call to `printString` was removed):

```st
RBRefactoryTestDataApp >> caller1
	| anObject |
	anObject := 5.
	self called: anObject + 1
		on1: 
			[:each | 
			^anObject]
```

#### Rename method (all)

I am a refactoring operation for renaming methods.

The new method name has to have the same number of arguments, but the order of arguments can be changed.

My preconditions verify that the number of arguments is the same and that the new method name isn't already used.

All references in senders of the old method are changed, either the method name only or the order of the supplied arguments.

##### Example

There are two ways to rename a method, one of them is rename all senders of method:

```st
(RBRenameMethodRefactoring 
		renameMethod: ('check', 'Class:') asSymbol
		in: RBBasicLintRuleTestData
		to: #checkClass1:
		permutation: (1 to: 1)) execute.
```

And the other is rename the method only in specific packages:

```st
|refactoring|
refactoring :=RBRenameMethodRefactoring 
		renameMethod: ('check', 'Class:') asSymbol
		in: RBBasicLintRuleTestData
		to: #checkClass1:
		permutation: (1 to: 1).
refactoring searchInPackages:  #(#'Refactoring-Tests-Core').
refactoring execute
```

#### Replace by another

I'm a refactoring operation for replace one method call by another one.

The new method's name can have a different number of arguments than the original method, if it has more arguments a list of initializers will be needed for them.

All senders of this method are changed by the other.

#### Example

```st
(RBReplaceMethodRefactoring  
	model: model
	replaceMethod: #anInstVar:
	in: RBBasicLintRuleTestData
	to: #newResultClass: 
	permutation: (1 to: 1)
	inAllClasses: true) execute
```

## Source Refactorings

#### Create cascade

I am a refactoring used to generate cascades in source code.

Two or more message sends to the same object are replaced by a cascaded message send. It expects a selection of the messages and the receiver variable.

#### Extract method

I am a refactoring for creating a method from a code fragment.

You can select an interval of some code in a method and call this refactoring to create a new method implementing that code and replace the code by calling this method instead. 
The new method needs to have as many arguments as the number of (temp)variables, the code refers to.

The preconditions are quite complex. The code needs to be parseable valid code.

#### Extract method to component

I am a refactoring for extracting code fragments to a new method.

Similar to `RBExtractMethodRefactoring`, but you can choose to which component (instance or agument variable) the new method is added. 
As such, the new method arguments will include an additional argument for the sender.
Based on the instance variable you choose for this method I will guess the class where to add this method, but you can change this class or add more classes.

#### Extract to temporary

Add a new temporary variable for the value of the selected code. Every place in this method using the same piece of code is replaced by accessing this new temporary variable instead.
As the code is now only evaluated once for initializing the variable value, this refactoring may modify the behavior if the code statements didn't evaluate to the same value on every call.

My preconditions verify that the new temporary name is a valid name and isn't already used (neither a temporary, an instance variable or a class variable).

#### Inline method

I am a refactoring for replacing method calls by the method implementation.

You can select a message send in a method and refactoring this message send to inline its code.
Any temporary variable used in the original message send is added into this method and renamed if there are already variables with this name.

My preconditions verify that the inlined method is not a primitive call, the method does not have multiple returns. I'll show a warning if the method is overriden in subclasses.


#### Inline method from component

I am a refactoring for replacing method calls by the method implementation.

Just like `RBInlineMethodRefactoring`, I replace a message send by the implementation of that  message , but you can provide the component
where this implementation is taken from or choose one if there are more than one implementor.
If the method implementation has some direct variable references, accessor for this variable are created (just as by the generate accessor refactoring).

#### Inline temporary

I am a refactoring to replace a temporary variable by code.

All references to the temporary variable in this method are replaced by the value used to initialize the temporary variable. 
The initialization and declaration of this variable will be removed. You need to select the variable and its initial assignment code to apply this refactoring.

#### Move variable definition

I am a refactoring for moving the definition of a variable to the block/scope where it is used.

For a method temporary variable declared but not initialized in the method scope and only used within a block, the definition can be moved to the block using this variable.

#### Rename temporary/parameter

I am a refactoring for renaming temporary variables.
This can be applied to method arguments as well.

The variable declaration and all references in this method are renamed.

My precondition verifies that the new name is a valid variable name and not an existing instance or a class variable name

#### Split cascade

I am a refactoring splitting a cascade message send to multiple messages.

You can select an interval containing a cascade expression. The refactoring will split this expression to two message sends to the receiver. 

My preconditions verify that the selector containing the cascaded message send is defined in this class, and a cascade message can be found.

If the receiver of the cascade expression is a literal or the return value of another message send, I will add another temporary variable for the interim result.

#### Move temporary to instvar

I am a refactoring for changing a temporary variable to an instance variable.

My preconditions verify that this variable is not yet used as an instance variable in this class.

The temporary variable is added to the class definition and removed from the temporary declaration in this method .

If this instance variable is already used in a subclass it will be removed from that class, because subclasses already inherit this attribute.

The temporary variables with the same name in hierarchy will be removed, and replaced with the new instance variable.

##### Example

Script refactoring:

```st
(RBTemporaryToInstanceVariableRefactoring 
    class: MyClassA
    selector: #someMethod
    variable: 'log') execute
```

Before refactoring:

```st
Object subclass: #MyClassA
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'example'

MyClassA >> someMethod 
    |log aNumber|
    log := self newLog.
    log isNil.
    aNumber := 5.

MyClassA >> anotherMethod
    #(4 5 6 7) do: [:e | | log |
        log := e ]

MyClassA subclass: #MyClassB
	instanceVariableNames: 'log'
	classVariableNames: ''
	package: 'example'
```

After refactoring:

```st
Object subclass: #MyClassA
	instanceVariableNames: 'log'
	classVariableNames: ''
	package: 'example'

MyClassA >> someMethod 
    | aNumber |
    log := self newLog.
    log isNil.
    aNumber := 5.

MyClassA >> anotherMethod
    #(4 5 6 7) do: [:e | 
        log := e ]

MyClassA subclass: #MyClassB
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'example'
```

### Package Refactorings

#### Rename

I'm a refactoring to rename a package. My preconditions verify that the new name is different from the current package name and is a valid name.

I change all the references of the classes that are defined within the package, and if there is a manifest, it is updated with the new name of the package. 

Example

```st
(RBRenamePackageRefactoring 
				rename: (self getPackageNamed: #'Refactoring-Tests-Core')
				to: #'Refactoring-Tests-Core1') execute.
```
